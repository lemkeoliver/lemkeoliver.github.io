/*
	This is the main Magma code for the paper "Inductive methods for counting number fields," by Alberts, Lemke Oliver, Wang, and Wood.
	Alberts and Lemke Oliver are primarily responsible for writing, maintaining, and running this code.
	
	The point of this file is to serve as the main hub for implementing the inductive strategy outlined by our paper.  
	Running it will create two files, both lists of information about permutation groups:
		*: A .csv file, in the format "Degree, Label, Malle, Bound, Conjecture"
			**: The degree and label entries to identify the permutation group, e.g. as Magma's PermutationGroup(Degree, Label)
			**: Malle is the Malle index of G, i.e. the reciprocal of the conjectural exponent of X in the counting function for G-extensions
			**: Bound is the upper bound on the power of X in the count of G-extensions that we provide from this computation
			**: Conjecture is a boolean, indicating whether the strong Malle conjecture is known for G
		*: A .mag file that, on loading in Magma, will load the results of this computation as an array.  Each element of the array is a record of (bespoke) type GroupCountingInfo, which has the following attributes:
			**: degree, label, order, malleindex, bound, conjecture, isnilpotent, issolvable, isconcentrated
			**: Most of these are self-explanatory, and have the same meaning as in the .csv
*/

/* 
	We now load a series of auxiliary magma files, which contain a number of functions that will be of use later.
	None of these will execute any code just yet.
*/

load "utils/CountingInvariants.mag";
	// Contains the basic code to compute the index of an element and a permutation group, along with the subgroup generated by the minimal index elements
	
load "utils/NumberFieldBounds.mag";
	// Implements bounds from other papers (e.g. the Schmidt bound) on number fields by Galois group

load "utils/InitializeDatabase.mag";
	// Will be used to initialize the database, and contains the definition of the GroupCountingInfo record.
	
load "utils/GroupConstructions.mag";
	// Has code used to create basic kinds of groups

load "utils/Comparing_Orderings.mag";
	// Has code to used to compare different pushforward discriminants

load "utils/Pontryagin_Dual_Class_Group_Bounds.mag";
	// Implemenets a function to compute a bound on H1_ur using the Pontryagin dual


// We're now reading to actually some of these functions.

MaxDegree:=23;

print "";
print "Initializing database with degrees up to", MaxDegree;


Database:= InitializeDatabase(MaxDegree);

print "....Done.";
print "";

/*
Inputs the known results for groups of small degree,
nilpotent groups, and S3 x  groups.
*/
load "utils/ConjectureIsKnown.mag";

/*
The following file inductively implements Theorem 1.9 and Theorem 1.10 on the Database. The code may need to be
repeated multiple times for optimal results.
*/
number_of_repeats:=3;

load "utils/InductiveCounting.mag";

TimeString := Time();
TimeString := Substring(TimeString, Index(TimeString," ")+1,10);

File := "SavedDatabase_" cat Sprint(MaxDegree) cat "_" cat Sprint(number_of_repeats) cat "_" cat TimeString cat".mag";
GCRStr := "GroupCountingInfo := recformat< degree:RngIntElt, label:RngIntElt, order:RngIntElt, malleindex:RngIntElt, bound:FldReElt, conjecture:BoolElt, isnilpotent:BoolElt, issolvable:BoolElt, isconcentrated:BoolElt >; \n";
DBStr := "Database:=" cat Sprint(Database) cat ";\n";

PrintFile( File, GCRStr cat DBStr);

quit;
